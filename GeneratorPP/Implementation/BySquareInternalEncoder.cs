using System;
using System.IO;
using System.Text;
using System.Xml;
using Digital.Slovensko.Ekosystem.GeneratorPP.Models.BySquare;

namespace Digital.Slovensko.Ekosystem.GeneratorPP.Implementation
{
    /// <summary>
    /// BySquare QR string encoder, custom implementation.
    /// </summary>
    public class BySquareInternalEncoder : IBySquareEncoder
    {
        #region BySquare Constants and Presets

        /// <summary>
        /// PayBySquare limit is 550 utf-8 characters 
        /// </summary>
        private const int MaxLength = 550;

        /// <summary>
        /// Gets the BySquare payload data delimiter.
        /// </summary>
        /// <value>
        /// The delimiter is ASCII character for horizontal tab (0x09).
        /// </value>
        private char Delimiter { get; } = '\x09';

        /// <summary>
        /// Gets the pay by square header.
        /// </summary>
        /// <value>
        /// The pay by square header.
        /// </value>
        /// <remarks>
        /// Determined by inspection of QR Strings generated by BySquare web service.
        /// </remarks>
        private byte[] PayBySquareHeader { get; } = {0, 0};

        #endregion BySquare Constants and Presets

        /// <summary>
        /// Encodes given document as QR string.
        /// </summary>
        /// <param name="document">The document.</param>
        /// <returns>QR string</returns>
        /// <exception cref="NotSupportedException">Unknown type of BySquareDocument.</exception>
        /// <exception cref="InvalidDataException">PayBySquare limit is 550 utf-8 characters.</exception>
        public string Encode(BySquareDocument document)
        {
            string serializedDocument = document switch
            {
                Pay pay         => this.Encode(pay),
                Invoice invoice => this.Encode(invoice),
                _               => throw new NotSupportedException("Unknown type of BySquareDocument."),
            };
            if (serializedDocument.Length > MaxLength)
                throw new InvalidDataException("PayBySquare limit is 550 utf-8 characters.");

            var payload = Encoding.UTF8.GetBytes(serializedDocument);
            return this.EncodeBytes(payload);
        }

        /// <summary>
        /// Deserializes the specified qrstring.
        /// </summary>
        /// <param name="qrstring">The qrstring.</param>
        /// <exception cref="NotImplementedException"></exception>
        public BySquareDocument Decode(string qrstring)
        {
            throw new NotImplementedException("Reading of QR strings is not supported.");
        }

        /// <summary>
        /// Serializes as qr string.
        /// </summary>
        /// <param name="document">The document.</param>
        /// <exception cref="NotImplementedException">Invoice document are not supported.</exception>
        public string Encode(Invoice document)
        {
            throw new NotImplementedException("Invoice documents are not supported.");
        }

        /// <summary>
        /// Encodes the specified payload.
        /// </summary>
        /// <param name="payload">The payload data.</param>
        /// <returns>QR string.</returns>
        public string EncodeBytes(byte[] payload)
        {
            // get crc bytes
            var crc = new Crc32().ComputeHash(payload);
            Array.Reverse(crc);

            // copy crc and payload
            var toBeCompressed = new byte[crc.Length + payload.Length];
            Array.Copy(crc, 0, toBeCompressed, 0, crc.Length);
            Array.Copy(payload, 0, toBeCompressed, crc.Length, payload.Length);

            // compress with LZMA
            var compressed = this.Compress(toBeCompressed);

            // copy header [2B], original data length [2B] and compressed data
            var length = BitConverter.GetBytes((ushort) toBeCompressed.Length);
            var toBeEncoded = new byte[PayBySquareHeader.Length + length.Length + compressed.Length];
            Array.Copy(this.PayBySquareHeader, toBeEncoded, this.PayBySquareHeader.Length);
            Array.Copy(length, 0, toBeEncoded, this.PayBySquareHeader.Length, length.Length);
            Array.Copy(compressed, 0, toBeEncoded, this.PayBySquareHeader.Length + length.Length, compressed.Length);

            // encode with Base32Hex
            return Base32.ToBase32String(toBeEncoded);
        }

        /// <summary>
        /// Decodes the specified QR string.
        /// </summary>
        /// <param name="qrstring">The QR string.</param>
        /// <returns>The payload data.</returns>
        /// <exception cref="InvalidDataException">Checksum of decompressed data does not match.</exception>
        public byte[] DecodeBytes(string qrstring)
        {
            // decode from Base32Hex
            var data2 = Base32.FromBase32String(qrstring);

            // data[0-1] // PayBySquare header
            // data[2-3] // original data length
            var originalDataLength = data2[2] + (data2[3] << 8);

            // skip first 4 bytes (PayBySquare qr code header + original data length)
            var payload = this.Decompress(data2, 4, originalDataLength);

            // first 4 bytes is crc32
            var crc = new Crc32().ComputeHash(payload, 4, originalDataLength - 4);
            Array.Reverse(crc);

            if (BitConverter.ToInt32(crc, 0) != BitConverter.ToInt32(payload, 0))
                throw new InvalidDataException("Checksum of decompressed data does not match.");

            return payload;
        }

        #region Compression

        /// <summary>
        /// LZMA encoder properties for PayBySquare
        /// LC = 3
        /// LP = 0
        /// PB = 2
        /// Dictionary size = 128 kiB (0x00020000 B)
        /// </summary>
        /// <remarks>
        /// 93 = LC + 9 * (LP + 5 * PB)
        /// </remarks>
        public readonly byte[] LzmaDecoderProperties = { 93, 00, 00, 02, 00 };

        /// <summary>
        /// The dictionary size is 128 kiB (0x00020000 B)
        /// </summary>
        public readonly int LzmaEncoderDictionarySize = 0x020000;

        /// <summary>
        /// Compresses the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        protected byte[] Compress(byte[] data)
        {
            using var output = new MemoryStream();
            
            // compress data
            var encoderProperties = new SharpCompress.Compressors.LZMA.LzmaEncoderProperties(false, this.LzmaEncoderDictionarySize);
            using (var compressor = new SharpCompress.Compressors.LZMA.LzmaStream(encoderProperties, false, output))
            {
                // compressor flushes to output stream at dispose
                compressor.Write(data, 0, data.Length);
            }

            // return the compressed data
            return output.ToArray();
        }

        /// <summary>
        /// Decompresses the specified data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="index">The index.</param>
        /// <param name="originalDataLength">Length of the original data.</param>
        protected byte[] Decompress(byte[] data, int index, int originalDataLength)
        {
            // PayBySquare limit is 550 utf-8 characters 
            // longest utf-8 character is 4 bytes
            var buffer = new byte[originalDataLength];

            // decompress data
            using (var input = new MemoryStream(data, index, data.Length - index))
            using (var decompressor = new SharpCompress.Compressors.LZMA.LzmaStream(this.LzmaDecoderProperties, input, input.Length, originalDataLength))
            {
                decompressor.Read(buffer, 0, originalDataLength);
            }

            // return the compressed data
            return buffer;
        }

        #endregion Compression

        /// <summary>
        /// Safe version of the <see cref="M:string.Substring"/> function.
        /// </summary>
        /// <param name="text">The text.</param>
        /// <param name="start">The start.</param>
        /// <param name="length">The length.</param>
        protected string SafeSubstring(string text, int start, int length)
        {
            if (string.IsNullOrEmpty(text))
                return text;

            if (start >= text.Length)
                return string.Empty;

            if (start < 0)
                start = 0;

            if (length > text.Length - start)
                length = text.Length - start;

            if (length <= 0)
                return string.Empty;

            return text
                .Substring(start, length)
                .Replace(Delimiter, ' ');
        }

        /// <summary>
        /// Encodes the given document as QR string.
        /// </summary>
        /// <param name="document">The document.</param>
        public string Encode(Pay document)
        {
            var builder = new StringBuilder();

            builder.Append(Delimiter);
            builder.Append(document.Payments.Count);

            foreach (var payment in document.Payments)
            {
                this.EncodePayment(builder, payment);
            }

            return builder.ToString();
        }

        /// <summary>
        /// Encodes the payment.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="payment">The payment.</param>
        private void EncodePayment(StringBuilder builder, Payment payment)
        {
            // 3. PaymentOptions
            builder.Append(Delimiter);
            {
                var rawValue = ((int) payment.PaymentOptionsEnum).ToString();
                var sanitizedValue = rawValue[0];
                builder.Append(sanitizedValue);
            }

            // 4. Amount
            builder.Append(Delimiter);
            if (payment.Amount.HasValue)
            {
                var rawValue = XmlConvert.ToString(payment.Amount.Value);
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 15);
                builder.Append(sanitizedValue);
            }

            // 5. CurrencyCode
            builder.Append(Delimiter);
            {
                var rawValue = payment.CurrencyCode;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 3);
                builder.Append(sanitizedValue);
            }

            // 6. PaymentDueDate
            builder.Append(Delimiter);
            if (payment.PaymentDueDate.HasValue)
            {
                var rawValue = payment.PaymentDueDate.Value.ToString("yyyyMMdd");
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 8);
                builder.Append(sanitizedValue);
            }

            // 7. VariableSymbol
            builder.Append(Delimiter);
            {
                var rawValue = payment.VariableSymbol;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 10);
                builder.Append(sanitizedValue);
            }

            // 8. ConstantSymbol
            builder.Append(Delimiter);
            {
                var rawValue = payment.ConstantSymbol;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 4);
                builder.Append(sanitizedValue);
            }

            // 9. SpecificSymbol
            builder.Append(Delimiter);
            {
                var rawValue = payment.SpecificSymbol;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 10);
                builder.Append(sanitizedValue);
            }

            // 10. OriginatorsReferenceInformation
            builder.Append(Delimiter);
            {
                var rawValue = payment.OriginatorsReferenceInformation;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 35);
                builder.Append(sanitizedValue);
            }

            // 11. PaymentNote
            builder.Append(Delimiter);
            {
                var rawValue = payment.PaymentNote;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 140);
                builder.Append(sanitizedValue);
            }

            // 12. BankAccounts
            builder.Append(Delimiter);
            {
                var rawValue = payment.BankAccounts.Count.ToString();
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 3);
                builder.Append(sanitizedValue);

                foreach (var account in payment.BankAccounts)
                {
                    this.EncodeBankAccount(builder, account);
                }
            }

            // 15. StandingOrderExt
            builder.Append(Delimiter);
            {
                var rawValue = "0";
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 1);
                builder.Append(sanitizedValue);
            }

            // 20. DirectDebitExt
            builder.Append(Delimiter);
            {
                var rawValue = "0";
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 1);
                builder.Append(sanitizedValue);
            }

            // 31. BeneficiaryName
            builder.Append(Delimiter);
            {
                var rawValue = payment.BeneficiaryName;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 70);
                builder.Append(sanitizedValue);
            }

            // 32. BeneficiaryAddressLine1
            builder.Append(Delimiter);
            {
                var rawValue = payment.BeneficiaryAddressLine1;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 70);
                builder.Append(sanitizedValue);
            }

            // 33. BeneficiaryAddressLine2
            builder.Append(Delimiter);
            {
                var rawValue = payment.BeneficiaryAddressLine2;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 70);
                builder.Append(sanitizedValue);
            }
        }

        /// <summary>
        /// Encodes the bank account.
        /// </summary>
        /// <param name="builder">The builder.</param>
        /// <param name="account">The account.</param>
        private void EncodeBankAccount(StringBuilder builder, BankAccount account)
        {
            // 13. IBAN
            builder.Append(Delimiter);
            {
                var rawValue = account.IBAN;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 34);
                builder.Append(sanitizedValue);
            }

            // 14. BIC
            builder.Append(Delimiter);
            {
                var rawValue = account.BIC;
                var sanitizedValue = this.SafeSubstring(rawValue, 0, 11);
                builder.Append(sanitizedValue);
            }
        }
    }
}
